// services/ReportServices/ReportServices.js
const { getDatabases } = require('../../utils/databaseHelper'); // Adjust the path if necessary
const { getDatabasesMultiple } = require('../../utils/databaseHelperMultiple'); // Adjust the path if necessary
const databaseController = require("../../controllers/databaseController")
const { QueryTypes } = require('sequelize');
const dateFns = require('date-fns');
const { format, getYear, getMonth } = require('date-fns');

exports.findSpeficlyStaticTblDataCurrentTran = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);

    // Get the database name from the Sequelize instance
    const stockmasterDbName = stockmasterDb.getDatabaseName(); // Ensure this method is available

    const sqlQuery = `
      SELECT 
          t.*, 
          c.MajorDescription AS MajorDescription,
          s.Sub1Description AS Sub1Description,
          w.Sub2Description AS Sub2Description
      FROM 
          202408tbldata_current_tran AS t
      LEFT JOIN 
          ${stockmasterDbName}.tblcategory AS c ON t.majorno = c.MajorNo
      LEFT JOIN 
          ${stockmasterDbName}.tblcategory_sub1 AS s ON t.sub1no = s.Sub1No
      LEFT JOIN 
          ${stockmasterDbName}.tblcategory_sub2 AS w ON t.sub2no = w.Sub2No;
    `;

    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;

  } catch (error) {
    throw new Error(error.message);
  }
};
exports.companydetailstblReg = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tblreg`;
    const results = await stockmasterDb.query(sqlQuery, { type: stockmasterDb.QueryTypes.SELECT });
    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.acrossReport = async (startDate, endDate) => {
  try {
    const activeDatabases = databaseController.getActiveDatabasesMultiple();

    // Get the history and stockmaster databases using the utility
    const { historyDbs, stockmasterDbs } = getDatabasesMultiple(activeDatabases);
    
    // Initialize an object to hold results with stock codes as keys
    const allResults = {};
    let grandTotalQty = 0; // Initialize a variable for the grand total

    // Loop through each database
    for (const historyDb of historyDbs) {
      const dbName = historyDb.config.database; // Get the current database name
      // Get all tables in the current database
      const tables = await historyDb.query("SHOW TABLES", { type: historyDb.QueryTypes.SELECT });

      // Collect all tables matching the pattern YYYYMMtbldata_current_tran
      const matchingTables = [];

      tables.forEach(table => {
        const tableName = Object.values(table)[0]; // Extract table name
        const match = tableName.match(/^(\d{6})tbldata_current_tran$/);
        if (match) {
          matchingTables.push(tableName); // Collect matching table names
        }
      });

      // Query each matching table
      for (const table of matchingTables) {
        // Modify the SQL query to include date filtering if dates are provided
        let sqlQuery = `SELECT stockcode, stockdescription, qty FROM ${table}`;
        
        if (startDate && endDate) {
          // Validate date format
          if (new Date(startDate) > new Date(endDate)) {
            throw new Error('Start date cannot be greater than end date');
          }

          sqlQuery += ` WHERE datetime BETWEEN :startDate AND :endDate`;
        }
        
        const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT,
           timeout: 90000, replacements: { startDate, endDate }});
        // Aggregate results
        for (const { stockcode, stockdescription, qty } of results) {
          if (!allResults[stockcode]) {
            allResults[stockcode] = {
              stockcode,
              stockdescription,
              qtyByDb: { [dbName]: qty }, // Initialize with current database's quantity
              totalQty: qty // Initialize total quantity
            };
          } else {
            allResults[stockcode].qtyByDb[dbName] = (allResults[stockcode].qtyByDb[dbName] || 0) + qty; // Sum quantities for this database
            allResults[stockcode].totalQty += qty; // Sum total quantities
          }
          grandTotalQty += qty; // Add to the grand total
        }
      }
    }

    // Check if any data was found
    if (Object.keys(allResults).length === 0) {
      throw new Error('No data found');
    }

    // Prepare final results
    const finalResults = Object.keys(allResults).map(stockcode => {
      const { stockdescription, qtyByDb, totalQty } = allResults[stockcode];
      return {
        stockcode,
        stockdescription,
        ...qtyByDb, // Spread quantities by database
        totalQty: parseFloat(totalQty.toFixed(2)) // Add total quantity for this stock code
      };
    });

    // Add missing stock codes with zero quantities for each database
    for (const dbName of historyDbs.map(db => db.config.database)) {
      finalResults.forEach(item => {
        if (!(dbName in item)) {
          item[dbName] = 0; // Assign 0 if the stock code is missing in the database
        }
      });
    }

    // Round total quantities for each database
    finalResults.forEach(item => {
      Object.keys(item).forEach(key => {
        if (typeof item[key] === 'number') {
          item[key] = parseFloat(item[key].toFixed(2)); // Round to 2 decimal places
        }
      });
    });

    grandTotalQty = parseFloat(grandTotalQty.toFixed(2)); // Round grandTotalQty to 2 decimal places

    return {
      finalResults, // This will now include results grouped by stock codes with quantities per database
      grandTotalQty // Include the grand total in the return value
    };
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.allTblDataCancelTran = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldatacancel_tran`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

// Service Function to handle multiple table names dynamically
exports.tblDataCancelTranSearchTables = async (tableNames) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb } = getDatabases(activeDatabases);

    // Split the table names by comma and validate each one
    const tables = tableNames.split(',').map(name => name.trim());

    // Validate each table name to avoid SQL injection
    tables.forEach(tableName => {
      if (!/^\d{6}tbldata_cancel_tran$/.test(tableName)) {
        throw new Error(`Invalid table name: ${tableName}`);
      }
    });

    // Initialize an array to hold the results
    const results = [];

    // Query each table and concatenate the results
    for (const tableName of tables) {
      let sqlQuery = `SELECT * FROM ${tableName}`;
      const tableResults = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      results.push(...tableResults);
    }

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblDataPrice = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldataprice`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.tblDataPriceSearchTables = async (tableNames) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb } = getDatabases(activeDatabases);

    // Split the table names by comma and validate each one
    const tables = tableNames.split(',').map(name => name.trim());

    // Validate each table name to avoid SQL injection
    tables.forEach(tableName => {
      if (!/^\d{6}tbldata_price$/.test(tableName)) {
        throw new Error(`Invalid table name: ${tableName}`);
      }
    });

    // Initialize an array to hold the results
    const results = [];

    // Query each table and concatenate the results
    for (const tableName of tables) {
      let sqlQuery = `SELECT * FROM ${tableName}`;
      const tableResults = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      results.push(...tableResults);
    }

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.tblDataStockActivitySearchTables = (tableNames, stockcode = null) => {
  return new Promise(async (resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();
      const { historyDb } = getDatabases(activeDatabases);
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate table names
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_stockactivity$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      const limit = 1000; // Records per page
      let allResults = []; // To store results from all tables

      // Fetch data for each table in parallel using Promise.all
      const tableQueries = tables.map(async (tableName) => {
        const countQuery = `
          SELECT COUNT(*) as total
          FROM ${tableName}
          ${stockcode ? `WHERE stockcode = '${stockcode}'` : ''};`;
        
        const totalCountResult = await historyDb.query(countQuery, { type: historyDb.QueryTypes.SELECT });
        const totalCount = totalCountResult[0].total;
        console.log(`Total records in ${tableName}: ${totalCount}`);

        let page = 1;
        let tableResults = [];

        while ((page - 1) * limit < totalCount) {
          const offset = (page - 1) * limit;
          let sqlQuery = `
            SELECT DISTINCT(stockcode), datetime, stockdescription, openqty,
              FORMAT(openqty + SUM(receivedqty) + SUM(adjustedqty) - SUM(soldqty) - SUM(usedincombinedqty) + SUM(stocktakediffqty), '0.00') AS closeqty,
              SUM(soldqty) AS soldqty, 
              SUM(receivedqty) AS receivedqty, 
              SUM(adjustedqty) AS adjustedqty, 
              SUM(usedincombinedqty) AS usedincombinedqty, 
              SUM(stocktakediffqty) AS stocktakediffqty
            FROM ${tableName}
            ${stockcode ? `WHERE stockcode = '${stockcode}'` : ''}
            GROUP BY stockcode
            LIMIT ${limit} OFFSET ${offset};`;

          const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
          tableResults.push(...results);
          page++;
        }

        return tableResults; // Return results for the current table
      });

      // Wait for all table queries to finish
      const results = await Promise.all(tableQueries);
      allResults = results.flat(); // Flatten results from all tables

      if (allResults.length === 0) {
        return reject(new Error('No data found'));
      }

      // Map to limit fields in the response
      const limitedFieldResults = allResults.map(item => {
       
        return {
          StockCode: item.stockcode,
          DateTime: item.datetime,
          StockDescription: item.stockdescription,
          OpenQty: parseFloat(item.openqty),
          CloseQty: parseFloat(item.closeqty),
          SoldQty: parseFloat(item.soldqty),
          ReceivedQty: parseFloat(item.receivedqty),
          AdjustedQty: parseFloat(item.adjustedqty),
          UsedInCombinedQty: parseFloat(item.usedincombinedqty),
          StockTakeDiffQty: parseFloat(item.stocktakediffqty)
        };
      });

      // Group by StockCode and StockDescription and calculate the totals for each group
      const groupedResults = limitedFieldResults.reduce((acc, item) => {
        const { StockCode, StockDescription, OpenQty, CloseQty, SoldQty, ReceivedQty, AdjustedQty, UsedInCombinedQty, StockTakeDiffQty } = item;
        const key = `${StockCode}-${StockDescription}`;
        if (!acc[key]) {
          acc[key] = {
            StockCode,
            StockDescription,
            OpenQtytotalAmount: 0,
            CloseQtytotalAmount: 0,
            SoldQtytotalAmount: 0,
            ReceivedQtytotalAmount: 0,
            AdjustedQtytotalAmount: 0,
            UsedInCombinedQtytotalAmount: 0,
            StockTakeDiffQtytotalAmount: 0,
            transactions: []
          };
        }
        acc[key].OpenQtytotalAmount += OpenQty;
        acc[key].CloseQtytotalAmount += CloseQty;
        acc[key].SoldQtytotalAmount += SoldQty;
        acc[key].ReceivedQtytotalAmount += ReceivedQty;
        acc[key].AdjustedQtytotalAmount += AdjustedQty;
        acc[key].UsedInCombinedQtytotalAmount += UsedInCombinedQty;
        acc[key].StockTakeDiffQtytotalAmount += StockTakeDiffQty;

        acc[key].transactions.push(item);
        return acc;
      }, {});

      const groupedArray = Object.values(groupedResults);
      resolve({ groupedArray }); // Return the result
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.allTblPayout = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldatapayout`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblStockActivity = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldatastockactivity`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.tblDataPayoutSearchTables = async (tableNames) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb } = getDatabases(activeDatabases);

    // Split the table names by comma and validate each one
    const tables = tableNames.split(',').map(name => name.trim());

    // Validate each table name to avoid SQL injection
    tables.forEach(tableName => {
      if (!/^\d{6}tblPayout$/.test(tableName)) {
        throw new Error(`Invalid table name: ${tableName}`);
      }
    });

    // Initialize an array to hold the results
    const results = [];

    // Query each table and concatenate the results
    for (const tableName of tables) {
      let sqlQuery = `SELECT * FROM ${tableName}`;
      const tableResults = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      results.push(...tableResults);
    }

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblDataCreditorsTran = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldatacreditor_tran`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblCreditorsValue = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tblcreditorsvalue`;
    const results = await stockmasterDb.query(sqlQuery, { type: stockmasterDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblDebtorsValue = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldebtorsvalue`;
    const results = await stockmasterDb.query(sqlQuery, { type: stockmasterDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblStockValue = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tblstockvalues`;
    const results = await stockmasterDb.query(sqlQuery, { type: stockmasterDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblDataDebtorsTran=async ()=>{

  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);
    let sqlQuery = `SELECT * FROM tbldatadebtor_tran`;
    const results = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
}
exports.allDepartmentsWithCategories = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb } = getDatabases(activeDatabases);

    // Query with LEFT JOIN to include 'MajorNo = 0' as a valid case
    let sqlQuery = `
      SELECT 
        COALESCE(c.MajorNo, 0) AS MajorNo, 
        c.MajorDescription,
        COALESCE(sub1.Sub1No, 0) AS Sub1No,
        COALESCE(sub1.Sub1Description, '') AS Sub1Description,
        COALESCE(sub2.Sub2No, 0) AS Sub2No,
        COALESCE(sub2.Sub2Description, '') AS Sub2Description
      FROM tblcategory AS c
      LEFT JOIN tblcategory_sub1 AS sub1 ON c.MajorNo = sub1.MajorNo
      LEFT JOIN tblcategory_sub2 AS sub2 ON c.MajorNo = sub2.MajorNo AND sub1.Sub1No = sub2.Sub1No
    `;

    const results = await stockmasterDb.query(sqlQuery, { type: stockmasterDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allTblDataProducts = async (majorNo, sub1No, sub2No, includeNegativeStockonHand = false,includeNegativeLastCostPrice = false, includeNegativeAvarageCostPrice = false, includeNegativeLaybyeStock = false,includeZeroStockonHand=false,includeZeroLastCostPrice=false,includeZeroAvarageCostPrice=false,includeZeroLaybyeStock=false,includeOnlyPositiveStock=false, pageSize = 6000) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { stockmasterDb } = getDatabases(activeDatabases);

    // Step 1: Build the count query with dynamic filters
    let countQuery = `SELECT COUNT(*) AS totalCount FROM tblproducts`;
    const whereConditions = [];
    const replacements = {};

    if (majorNo) {
      whereConditions.push(`tblproducts.MajorNo = :majorNo`);
      replacements.majorNo = majorNo;
    }
    if (sub1No) {
      whereConditions.push(`tblproducts.Sub1No = :sub1No`);
      replacements.sub1No = sub1No;
    }
    if (sub2No) {
      whereConditions.push(`tblproducts.Sub2No = :sub2No`);
      replacements.sub2No = sub2No;
    }

    // Step 2: If includeNegative is true, add condition for negative StockonHand or subcategories
    if (includeNegativeStockonHand) {
      whereConditions.push(`(tblproducts.StockonHand < 0)`); 
    }
    if (includeNegativeLastCostPrice) {
      whereConditions.push(`(tblproducts.LastCostPrice < 0)`); 
    } if (includeNegativeAvarageCostPrice) {
      whereConditions.push(`(tblproducts.AvarageCostPrice < 0)`);
    } if (includeNegativeLaybyeStock) {
      whereConditions.push(`(tblproducts.LaybyeStock < 0)`);
    }
    // Check for zero stock in addition to negative checks
    if (includeZeroStockonHand) {
        whereConditions.push(`(tblproducts.StockonHand = 0)`); 
    }
    if (includeZeroLastCostPrice) {
        whereConditions.push(`(tblproducts.LastCostPrice = 0)`); 
    }
    if (includeZeroAvarageCostPrice) {
        whereConditions.push(`(tblproducts.AvarageCostPrice = 0)`);
    }
    if (includeZeroLaybyeStock) {
        whereConditions.push(`(tblproducts.LaybyeStock = 0)`);
    }
       // New condition for only positive values
       if (includeOnlyPositiveStock) {
        whereConditions.push(`(tblproducts.StockonHand > 0)`);
        whereConditions.push(`(tblproducts.LastCostPrice > 0)`);
        whereConditions.push(`(tblproducts.AvarageCostPrice > 0)`);
      }
  
    if (whereConditions.length > 0) {
      countQuery += ` WHERE ` + whereConditions.join(' AND ');
    }
    const countResult = await stockmasterDb.query(countQuery, {
      replacements,
      type: stockmasterDb.QueryTypes.SELECT,
    });
    const totalCount = countResult[0]?.totalCount || 0;
    const totalPages = Math.ceil(totalCount / pageSize);
    // Step 3: Fetch products with dynamic filtering and pagination
    const productPromises = Array.from({ length: totalPages }, (_, page) => {
      const offset = page * pageSize;
      let productsQuery = `
        SELECT 
          tblproducts.StockCode,
          tblproducts.StockBarCode,
          tblproducts.Description1,
          tblproducts.MajorNo,
          tblproducts.Sub1No,
          tblproducts.Sub2No,
          tblproducts.StockonHand,
          tblproducts.AvarageCostPrice,
          tblproducts.LastCostPrice,
          tblproducts.VatPercentage,
          tblproducts.DefaultSellingPrice,
          tblproducts.LaybyeStock,
          tblcategory.MajorNo AS CategoryMajorNo,
          tblcategory.MajorDescription,
          tblcategory_sub1.Sub1No AS CategorySub1No,
          tblcategory_sub1.Sub1Description,
          tblcategory_sub2.Sub2No AS CategorySub2No,
          tblcategory_sub2.Sub2Description AS CategorySub2Description
        FROM tblproducts
        LEFT JOIN tblcategory ON tblproducts.MajorNo = tblcategory.MajorNo
        LEFT JOIN tblcategory_sub1 ON tblproducts.Sub1No = tblcategory_sub1.Sub1No
        LEFT JOIN tblcategory_sub2 ON tblproducts.Sub2No = tblcategory_sub2.Sub2No
      `;

      if (whereConditions.length > 0) {
        productsQuery += ` WHERE ` + whereConditions.join(' AND ');
      }

      productsQuery += ` LIMIT :pageSize OFFSET :offset`;

      return stockmasterDb.query(productsQuery, {
        replacements: { ...replacements, pageSize, offset },
        type: stockmasterDb.QueryTypes.SELECT,
      });
    });

    const pagesResults = await Promise.all(productPromises);
    const allProducts = pagesResults.flat();

    // Process all products
    const processedProducts = allProducts.map(product => ({
      ...product,
      TotalAvarageCostPrice: Number(product.AvarageCostPrice) * Number(product.StockonHand || 0),
      TotalLastCostPrice: Number(product.LastCostPrice) * Number(product.StockonHand || 0),
      TotalSelling: Number(product.DefaultSellingPrice) * Number(product.StockonHand || 0),
    }));

    // Group products by MajorNo
    const groupedProducts = processedProducts.reduce((acc, product) => {
      const majorKey = product.CategoryMajorNo;
      if (!acc[majorKey]) {
        acc[majorKey] = {
          MajorNo: majorKey,
          MajorDescription: product.MajorDescription,
          Sub1Description: product.Sub1Description,
          CategorySub2Description: product.CategorySub2Description,
          products: [],
          totalStockOnHand: 0,
          totalLaybyeStock: 0,
          totalAvarageCostPrice: 0,
          totalLastCostPrice: 0,
          totalSelling: 0,
        };
      }

      acc[majorKey].products.push(product);
      acc[majorKey].totalStockOnHand += Number(product.StockonHand || 0);
      acc[majorKey].totalLaybyeStock += Number(product.LaybyeStock || 0);
      acc[majorKey].totalAvarageCostPrice += Number(product.TotalAvarageCostPrice || 0);
      acc[majorKey].totalLastCostPrice += Number(product.TotalLastCostPrice || 0);
      acc[majorKey].totalSelling += Number(product.TotalSelling || 0);

      return acc;
    }, {});

    const groupedArray = Object.values(groupedProducts);

    return {
      data: groupedArray,
      totalCount,
      pageSize,
    };

  } catch (error) {
    console.error(`Error fetching products data: ${error.message}`);
    console.error(`Stack Trace: ${error.stack}`); // More detailed error info
    throw new Error(`Error fetching products data: ${error.message}`);
  }
};
exports.tblDataCreditorsTranSearchTables = async (tableNames) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb } = getDatabases(activeDatabases);

    // Split the table names by comma and validate each one
    const tables = tableNames.split(',').map(name => name.trim());

    // Validate each table name to avoid SQL injection
    tables.forEach(tableName => {
      if (!/^\d{6}tbldata_creditors_tran$/.test(tableName)) {
        throw new Error(`Invalid table name: ${tableName}`);
      }
    });

    // Initialize an array to hold the results
    const results = [];

    // Query each table and concatenate the results
    for (const tableName of tables) {
      let sqlQuery = `SELECT * FROM ${tableName}`;
      const tableResults = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      results.push(...tableResults);
    }

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.tblDataDebtorsTranSearchTables = async (tableNames) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb } = getDatabases(activeDatabases);

    // Split the table names by comma and validate each one
    const tables = tableNames.split(',').map(name => name.trim());

    // Validate each table name to avoid SQL injection
    tables.forEach(tableName => {
      if (!/^\d{6}tbldebtor_tran$/.test(tableName)) {
        throw new Error(`Invalid table name: ${tableName}`);
      }
    });

    // Initialize an array to hold the results
    const results = [];

    // Query each table and concatenate the results
    for (const tableName of tables) {
      let sqlQuery = `SELECT * FROM ${tableName}`;
      const tableResults = await historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      results.push(...tableResults);
    }

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.DebtorsCreditNotesReportSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldebtor_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where Description starts with "Credit"
          const filteredResults = results.filter(result => result.Description.startsWith("Credit"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Credit transactions found', data: [] });
          }

           // Map to limit fields in the response
           const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
            DebtorCode: item.Debtorcode,
            Reference: item.Reference,
            Description: item.Description,
            Amount: item.Amount,
            UserName: item.UserName,
            DebtorName: item.DebtorName
          }));
  
         // Group by Creditorcode and CreditorName and calculate the total Amount for each group
         const groupedResults = limitedFieldResults.reduce((acc, item) => {
          const { DebtorCode, DebtorName, Amount } = item;
          const key = `${DebtorCode}-${DebtorName}`; // Create a unique key using Creditorcode and CreditorName
          if (!acc[key]) {
            acc[key] = { DebtorCode, DebtorName, totalAmount: 0, transactions: [] };
          }
          acc[key].totalAmount += Amount;
          acc[key].transactions.push(item);
          return acc;
        }, {});
        // Calculate the overall total amount
        const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
        // Convert the groupedResults object into an array
        const groupedArray = Object.values(groupedResults);
        // Resolve the result with both the grouped totals and the overall total
        resolve({ groupedArray, overallTotalAmount });
      })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.DebtorsDebitNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldebtor_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where TransType is "Debit"
          const filteredResults = results.filter(result => result.Description.startsWith("Debit"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Debit transactions found', data: [] });
          }

          // Map to limit fields in the response
          const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
    DebtorCode: item.Debtorcode,
    Reference: item.Reference,
    Description: item.Description,
    Amount: item.Amount,
    UserName: item.UserName,
    DebtorName: item.DebtorName
          }));
  
          // Group by Creditorcode and CreditorName and calculate the total Amount for each group
          const groupedResults = limitedFieldResults.reduce((acc, item) => {
            const { DebtorCode, DebtorName, Amount } = item;
            const key = `${DebtorCode}-${DebtorName}`; // Create a unique key using Creditorcode and CreditorName
            if (!acc[key]) {
              acc[key] = { DebtorCode, DebtorName, totalAmount: 0, transactions: [] };
            }
            acc[key].totalAmount += Amount;
            acc[key].transactions.push(item);
            return acc;
          }, {});
  
          // Calculate the overall total amount
          const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
  
          // Convert the groupedResults object into an array
          const groupedArray = Object.values(groupedResults);
  
          // Resolve the result with both the grouped totals and the overall total
          resolve({ groupedArray, overallTotalAmount });
        })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.DebtorsAccountNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldebtor_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where Description starts with "Account"
          const filteredResults = results.filter(result => result.Description.startsWith("Account"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Account transactions found', data: [] });
          }

          // Map to limit fields in the response
          const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
    DebtorCode: item.Debtorcode,
    Reference: item.Reference,
    Description: item.Description,
    Amount: item.Amount,
    UserName: item.UserName,
    DebtorName: item.DebtorName
          }));

            // Group by Creditorcode and CreditorName and calculate the total Amount for each group
            const groupedResults = limitedFieldResults.reduce((acc, item) => {
              const { DebtorCode, DebtorName, Amount } = item;
              const key = `${DebtorCode}-${DebtorName}`; // Create a unique key using Creditorcode and CreditorName
              if (!acc[key]) {
                acc[key] = { DebtorCode, DebtorName, totalAmount: 0, transactions: [] };
              }
              acc[key].totalAmount += Amount;
              acc[key].transactions.push(item);
              return acc;
            }, {});
    
            // Calculate the overall total amount
            const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
    
            // Convert the groupedResults object into an array
            const groupedArray = Object.values(groupedResults);
    
            // Resolve the result with both the grouped totals and the overall total
            resolve({ groupedArray, overallTotalAmount });
          })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};

exports.DebtorsPaymentNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldebtor_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where TransType is "Payment - Cash"
          const filteredResults = results.filter(result => result.Description.startsWith("Payment - Cash"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Account transactions found', data: [] });
          }

          // Map to limit fields in the response
          const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
    DebtorCode: item.Debtorcode,
    Reference: item.Reference,
    Description: item.Description,
    Amount: item.Amount,
    UserName: item.UserName,
    DebtorName: item.DebtorName
          }));

            // Group by Creditorcode and CreditorName and calculate the total Amount for each group
            const groupedResults = limitedFieldResults.reduce((acc, item) => {
              const { DebtorCode, DebtorName, Amount } = item;
              const key = `${DebtorCode}-${DebtorName}`; // Create a unique key using Creditorcode and CreditorName
              if (!acc[key]) {
                acc[key] = { DebtorCode, DebtorName, totalAmount: 0, transactions: [] };
              }
              acc[key].totalAmount += Amount;
              acc[key].transactions.push(item);
              return acc;
            }, {});
    
            // Calculate the overall total amount
            const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
    
            // Convert the groupedResults object into an array
            const groupedArray = Object.values(groupedResults);
    
            // Resolve the result with both the grouped totals and the overall total
            resolve({ groupedArray, overallTotalAmount });
          })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};


exports.CreditorsCreditNotesReportSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_creditors_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where Description starts with "Credit"
          const filteredResults = results.filter(result => result.Description.startsWith("Credit"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Credit transactions found', data: [] });
          }
           // Map to limit fields in the response
           const limitedFieldResults = filteredResults.map(item => ({
           
            DateTime: item.DateTime,
            Creditorcode: item.Creditorcode,
            Reference: item.Reference,
            Description: item.Description,
            Amount: item.Amount,
            UserName: item.UserName,
            CreditorName: item.CreditorName
          }));
  
         // Group by Creditorcode and CreditorName and calculate the total Amount for each group
         const groupedResults = limitedFieldResults.reduce((acc, item) => {
          const { Creditorcode, CreditorName, Amount } = item;
          const key = `${Creditorcode}-${CreditorName}`; // Create a unique key using Creditorcode and CreditorName
          if (!acc[key]) {
            acc[key] = { Creditorcode, CreditorName, totalAmount: 0, transactions: [] };
          }
          acc[key].totalAmount += Amount;
          acc[key].transactions.push(item);
          return acc;
        }, {});
        // Calculate the overall total amount
        const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
        // Convert the groupedResults object into an array
        const groupedArray = Object.values(groupedResults);
        // Resolve the result with both the grouped totals and the overall total
        resolve({ groupedArray, overallTotalAmount });
      })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.CreditorsDebitNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_creditors_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where TransType is "Debit"
          const filteredResults = results.filter(result => result.Description.startsWith("Debit"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Debit transactions found', data: [] });
          }
          // Map to limit fields in the response
          const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
            Creditorcode: item.Creditorcode,
    Reference: item.Reference,
    Description: item.Description,
    Amount: item.Amount,
    UserName: item.UserName,
    CreditorName: item.CreditorName
          }));
  
          // Group by Creditorcode and CreditorName and calculate the total Amount for each group
          const groupedResults = limitedFieldResults.reduce((acc, item) => {
            const { Creditorcode, CreditorName, Amount } = item;
            const key = `${Creditorcode}-${CreditorName}`; // Create a unique key using Creditorcode and CreditorName
            if (!acc[key]) {
              acc[key] = { Creditorcode, CreditorName, totalAmount: 0, transactions: [] };
            }
            acc[key].totalAmount += Amount;
            acc[key].transactions.push(item);
            return acc;
          }, {});
  
          // Calculate the overall total amount
          const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);
  
          // Convert the groupedResults object into an array
          const groupedArray = Object.values(groupedResults);
  
          // Resolve the result with both the grouped totals and the overall total
          resolve({ groupedArray, overallTotalAmount });
        })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.CreditorsInvoicesNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_creditors_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where Description starts with "Account"
          const filteredResults = results.filter(result => result.Description.startsWith("Account"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Account transactions found', data: [] });
          }
          // Map to limit fields in the response
          const limitedFieldResults = filteredResults.map(item => ({
            DateTime: item.DateTime,
            Creditorcode: item.Creditorcode,
            Reference: item.Reference,
            Description: item.Description,
            Amount: item.Amount,
            UserName: item.UserName,
            CreditorName: item.CreditorName
          }));

          // Group by Creditorcode and CreditorName and calculate the total Amount for each group
          const groupedResults = limitedFieldResults.reduce((acc, item) => {
            const { Creditorcode, CreditorName, Amount } = item;
            const key = `${Creditorcode}-${CreditorName}`; // Create a unique key using Creditorcode and CreditorName
            if (!acc[key]) {
              acc[key] = { Creditorcode, CreditorName, totalAmount: 0, transactions: [] };
            }
            acc[key].totalAmount += Amount;
            acc[key].transactions.push(item);
            return acc;
          }, {});

          // Calculate the overall total amount
          const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);

          // Convert the groupedResults object into an array
          const groupedArray = Object.values(groupedResults);

          // Resolve the result with both the grouped totals and the overall total
          resolve({ groupedArray, overallTotalAmount });
        })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};
exports.CreditorsPaymentNotesSearchTables = (tableNames) => {
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();

      // Get the history and stockmaster databases using the utility
      const { historyDb } = getDatabases(activeDatabases);

      // Split the table names by comma and validate each one
      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name to avoid SQL injection
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_creditors_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      // Initialize an array to hold the promises for querying each table
      const queryPromises = tables.map(tableName => {
        let sqlQuery = `SELECT * FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      // Resolve all the query promises
      Promise.all(queryPromises)
        .then((queryResults) => {
          // Flatten the array of results
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Filter results where TransType is "Payment - Cash"
          const filteredResults = results.filter(result => result.Description.startsWith("Payment - Cash"));

          if (filteredResults.length === 0) {
            return resolve({ message: 'No Payment transactions found', data: [] });
          }

         // Map to limit fields in the response
         const limitedFieldResults = filteredResults.map(item => ({
          DateTime: item.DateTime,
          Creditorcode: item.Creditorcode,
          Reference: item.Reference,
          Description: item.Description,
          Amount: item.Amount,
          UserName: item.UserName,
          CreditorName: item.CreditorName
        }));

        // Group by Creditorcode and CreditorName and calculate the total Amount for each group
        const groupedResults = limitedFieldResults.reduce((acc, item) => {
          const { Creditorcode, CreditorName, Amount } = item;
          const key = `${Creditorcode}-${CreditorName}`; // Create a unique key using Creditorcode and CreditorName
          if (!acc[key]) {
            acc[key] = { Creditorcode, CreditorName, totalAmount: 0, transactions: [] };
          }
          acc[key].totalAmount += Amount;
          acc[key].transactions.push(item);
          return acc;
        }, {});

        // Calculate the overall total amount
        const overallTotalAmount = limitedFieldResults.reduce((sum, item) => sum + item.Amount, 0);

        // Convert the groupedResults object into an array
        const groupedArray = Object.values(groupedResults);

        // Resolve the result with both the grouped totals and the overall total
        resolve({ groupedArray, overallTotalAmount });
     
        })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};

exports.HistoryProductSaleByInvoiceSearchTables = (tableNames) => { 
  return new Promise((resolve, reject) => {
    try {
      const activeDatabases = databaseController.getActiveDatabases();
      const { historyDb } = getDatabases(activeDatabases);

      const tables = tableNames.split(',').map(name => name.trim());

      // Validate each table name
      tables.forEach(tableName => {
        if (!/^\d{6}tbldata_current_tran$/.test(tableName)) {
          return reject(new Error(`Invalid table name: ${tableName}`));
        }
      });

      const queryPromises = tables.map(tableName => {
        let sqlQuery = `
        SELECT 
          datetime, 
          salenum, 
          stockcode, 
          stockdescription, 
          qty, 
          stockunitprice, 
          paymenttype, 
          averagecostprice, 
          lastcostprice, 
          linetotal, 
          cashupnum 
        FROM ${tableName}`;
        return historyDb.query(sqlQuery, { type: historyDb.QueryTypes.SELECT });
      });

      Promise.all(queryPromises)
        .then((queryResults) => {
          const results = [].concat(...queryResults);

          if (results.length === 0) {
            return reject(new Error('No data found'));
          }

          // Group results by salenum and calculate totals
          const groupedResults = results.reduce((acc, current) => {
            const { salenum, linetotal } = current; // assuming linetotal is the field to sum

            if (!acc[salenum]) {
              acc[salenum] = { 
                salenum, 
                transactions: [], 
                total: 0 // Initialize total
              };
            }
            
            acc[salenum].transactions.push(current);
            acc[salenum].total += linetotal; // Accumulate total

            return acc;
          }, {});

          // Convert to an array
          const finalResults = Object.values(groupedResults);

          // Calculate overall total
          const overallTotal = finalResults.reduce((sum, group) => sum + group.total, 0);

          // Resolve with final results and overall total
          resolve({ finalResults, overallTotal });
        })
        .catch((error) => reject(error));
    } catch (error) {
      reject(new Error(error.message));
    }
  });
};

// CurrentDebtorsAnalysisReport
exports.CurrentDebtorsAnalysis = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();

    // Get the history and stockmaster databases using the utility
    const { historyDb, stockmasterDb, debtorsDb } = getDatabases(activeDatabases);
    let sqlQuery = `
      SELECT 
        debtorcode, 
        debtorname, 
        debtorcell, 
        debtorphone, 
        AccountSystem, 
        currentbalance + 30days + 60days + 90days + 120days + 150days + 180days AS totalBalance, 
        balanceforward, 
        currentbalance, 
        30days, 
        60days, 
        90days, 
        120days, 
        150days, 
        180days 
      FROM 
        tbldebtor 
      WHERE 
        accountsystem = 'Normal'
    `;
    const results = await debtorsDb.query(sqlQuery, { type: debtorsDb.QueryTypes.SELECT });

    if (results.length === 0) {
      throw new Error('No data found');
    }
    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.PERVIOUSDebtorsAgeAnalysis = async (debtorGroup, previousAging, checkBalanceGreaterthanZero) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { historyDb, stockmasterDb, debtorsDb } = getDatabases(activeDatabases);

    // Convert previousAging to a Date object
    const previousAgingDate = new Date(previousAging);
    if (isNaN(previousAgingDate)) {
      throw new Error('Invalid date provided for previousAging');
    }

    // Define the SQL query
    let sqlQuery = `
      SELECT 
        tblageinfo.debtorcode, 
        tbldebtor.debtorname, 
        tbldebtor.debtorcell, 
        tbldebtor.debtorphone, 
        tbldebtor.AccountSystem, 
        tblageinfo.currentbalance + 
        tblageinfo.30days + 
        tblageinfo.60days + 
        tblageinfo.90days + 
        tblageinfo.120days + 
        tblageinfo.150days + 
        tblageinfo.180days AS totalBalance, 
        tblageinfo.balanceforward, 
        tblageinfo.currentbalance, 
        tblageinfo.30days, 
        tblageinfo.60days, 
        tblageinfo.90days, 
        tblageinfo.120days, 
        tblageinfo.150days, 
        tblageinfo.180days 
      FROM 
        tblageinfo 
      INNER JOIN 
        tbldebtor ON tblageinfo.debtorcode = tbldebtor.debtorcode 
      WHERE 
        tbldebtor.accountsystem = 'Normal' 
        AND tbldebtor.ACCTERMS = :debtorGroup 
        AND tblageinfo.currentagedate = :previousAging 
    `;

// Add the balance check if checkBalanceGreaterthanZero is true
if (checkBalanceGreaterthanZero) {
  sqlQuery += `
     AND (tblageinfo.currentbalance + 
             tblageinfo.30days + 
             tblageinfo.60days + 
             tblageinfo.90days + 
             tblageinfo.120days + 
             tblageinfo.150days + 
             tblageinfo.180days) <> 0
  `;}
    const results = await debtorsDb.query(sqlQuery, {
      type: debtorsDb.QueryTypes.SELECT,
      replacements: {
        debtorGroup,
        previousAging: dateFns.format(previousAgingDate, "yyyy-MM-dd HH:mm:ss") // Format the date
      }
    });

    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.PERVIOUSDebtorsAgeAnalysisGroupsAndPreviousAging = async () => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb } = getDatabases(activeDatabases);

    // Define the SQL query to get the required fields
    const sqlQuery = `
      SELECT 
        tblageinfo.currentagedate, 
        tbldebtor.ACCTERMS 
      FROM 
        tblageinfo 
      INNER JOIN 
        tbldebtor ON tblageinfo.debtorcode = tbldebtor.debtorcode
    `;

    const results = await debtorsDb.query(sqlQuery, {
      type: debtorsDb.QueryTypes.SELECT,
    });

    if (results.length === 0) {
      throw new Error('No data found');
    }

    // Grouping the results by ACCTERMS
    const groupedData = results.reduce((acc, item) => {
      const terms = item.ACCTERMS;

      // Skip empty terms
      if (terms) {
        if (!acc[terms]) {
          acc[terms] = {
            ACCTERMS: terms,
            currentagedates: []
          };
        }
        acc[terms].currentagedates.push(item.currentagedate);
      }

      return acc;
    }, {});

    // Convert the grouped object to an array
    const resultArray = Object.values(groupedData);

    return resultArray; // Return the grouped results
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.CURRENTDebtorsAgeAnalysis = async (debtorGroup = null, previousAging = null, checkBalanceGreaterthanZero = true) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb } = getDatabases(activeDatabases);
    // Start the base SQL query
    let sqlQuery = `
      SELECT 
          debtorcode, 
          debtorname, 
          debtorcell, 
          debtorphone, 
          AccountSystem, 
          currentbalance + 30days + 60days + 90days + 120days + 150days + 180days AS totalBalance,
          balanceforward, 
          currentbalance, 
          30days, 
          60days, 
          90days, 
          120days, 
          150days, 
          180days 
      FROM 
          tbldebtor
    `;

    const conditions = [];

    // Add conditions based on the presence of parameters
    if (debtorGroup) {
      conditions.push(`AccountSystem = :debtorGroup`);
    }
    if (previousAging) {
      conditions.push(`ACCTERMS = :previousAging`);
    }
    if (checkBalanceGreaterthanZero) {
      conditions.push(`(currentbalance + 30days + 60days + 90days + 120days + 150days + 180days) <> 0`);
    }

    // Append conditions to the SQL query if any exist
    if (conditions.length > 0) {
      sqlQuery += ' WHERE ' + conditions.join(' AND ');
    }

    // Execute the query
    const results = await debtorsDb.query(sqlQuery, {
      type: debtorsDb.QueryTypes.SELECT,
      replacements: {
        debtorGroup,
        previousAging
      }
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    // Catch and rethrow the error with a meaningful message
    throw new Error(error.message);
  }
};
exports.CURRENTDebtorsAgeAnalysisACCTERMSAndAccountSystem = async () => {  
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb } = getDatabases(activeDatabases);

    // Define the SQL query to get only distinct required fields
    const sqlQuery = `
      SELECT DISTINCT 
          AccountSystem, 
          ACCTERMS
      FROM 
          tbldebtor
    `;

    // Execute the query
    const results = await debtorsDb.query(sqlQuery, {
      type: debtorsDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    // Filter out entries with empty ACCTERMS and get unique results
    const uniqueResults = Array.from(
      new Set(results.filter(item => item.ACCTERMS !== "").map(JSON.stringify))
    ).map(JSON.parse);

    return uniqueResults;
  } catch (error) {
    throw new Error(error.message);
  }
};

exports.CreditorAnalysis = async (CmbPreviousAging, checkBalanceGreaterThanZero) => { 
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb } = getDatabases(activeDatabases); // Ensure correct reference
    const stockmasterDbName = stockmasterDb.getDatabaseName(); // Ensure this method is available

    // Start defining the SQL query
    let sqlQuery = `
      SELECT 
        tblageinfo.CreditorCode, 
        tblcreditor.CreditorName, 
        tblcreditor.creditorcell, 
        tblcreditor.creditorphone, 
        tblcreditor.creditoremail, 
        tblageinfo.currentbalance + 
        tblageinfo.30days + 
        tblageinfo.60days + 
        tblageinfo.90days + 
        tblageinfo.120days + 
        tblageinfo.150days + 
        tblageinfo.180days AS totalBalance, 
        tblageinfo.balanceforward, 
        tblageinfo.currentbalance, 
        tblageinfo.30days, 
        tblageinfo.60days, 
        tblageinfo.90days, 
        tblageinfo.120days, 
        tblageinfo.150days, 
        tblageinfo.180days 
      FROM 
        ${stockmasterDbName}.tblageinfo 
      INNER JOIN 
        ${stockmasterDbName}.tblcreditor 
      ON 
        tblageinfo.creditorcode = tblcreditor.creditorcode 
      WHERE 
        tblageinfo.currentagedate = '${format(new Date(CmbPreviousAging), "yyyy-MM-dd HH:mm:ss")}' 
    `;

    // Add the conditional check for balance if requested
    if (checkBalanceGreaterThanZero) {
      sqlQuery += `
        AND (tblageinfo.currentbalance + 
            tblageinfo.30days + 
            tblageinfo.60days + 
            tblageinfo.90days + 
            tblageinfo.120days + 
            tblageinfo.150days + 
            tblageinfo.180days) <> 0
      `;
    }

    // Execute the query using the stockmasterDb connection
    const results = await stockmasterDb.query(sqlQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.CreditorAnalysisCmbPreviousAging = async () => {   
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb } = getDatabases(activeDatabases);
    const stockmasterDbName = stockmasterDb.getDatabaseName();

    // SQL query to retrieve currentagedate
    const sqlQuery = `
      SELECT 
        tblageinfo.currentagedate 
      FROM 
        ${stockmasterDbName}.tblageinfo 
    `;

    // Execute the query
    const results = await stockmasterDb.query(sqlQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    // Remove duplicates using an object
    const uniqueDates = {};
    results.forEach(item => {
      uniqueDates[item.currentagedate] = true;
    });

    // Convert to desired format YYYY-MM-DD HH:mm:ss
    const formattedResults = Object.keys(uniqueDates).map(dateString => {
      const date = new Date(dateString);
      const formattedDate = date.toISOString().slice(0, 19).replace('T', ' ');
      return { currentagedate: formattedDate };
    });

    return formattedResults;
  } catch (error) {
    throw new Error(error.message);
  }
};


exports.CURRENTCreditorsAgeAnalysis = async (checkBalanceGreaterThanZero) => { 
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb } = getDatabases(activeDatabases); // Ensure correct reference
    const stockmasterDbName = stockmasterDb.getDatabaseName(); // Ensure this method is available

    // Start defining the SQL query
    let sqlQuery = `
      SELECT 
        creditorcode, 
        creditorname, 
        creditorcell, 
        creditorphone, 
        creditoremail, 
        currentbalance + 30days + 60days + 90days + 120days + 150days + 180days AS totalBalance, 
        balanceforward, 
        currentbalance, 
        30days, 
        60days, 
        90days, 
        120days, 
        150days, 
        180days 
      FROM 
        ${stockmasterDbName}.tblcreditor
    `;

    // Add the conditional check for totalBalance if requested
    if (checkBalanceGreaterThanZero) {
      sqlQuery += `
        WHERE (currentbalance + 
               30days + 
               60days + 
               90days + 
               120days + 
               150days + 
               180days) <> 0
      `;
    }

    // Execute the query using the stockmasterDb connection
    const results = await stockmasterDb.query(sqlQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    return results;
  } catch (error) {
    throw new Error(error.message);
  }
};
exports.allDataMinStockLevel = async () => { 
  try {
    // Retrieve active databases
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb } = getDatabases(activeDatabases); // Ensure correct reference
    const stockmasterDbName = stockmasterDb.getDatabaseName(); // Ensure this method is available

    // Define the SQL query to find products with a minimum stock level not equal to 0 and stock on hand less than minimum stock
    const sqlQuery = `
      SELECT * 
       FROM ${stockmasterDbName}.tblproducts
      WHERE MinStock <> 0 
        AND StockonHand < MinStock
    `;

    // Execute the query using the stockmasterDb connection
    const results = await stockmasterDb.query(sqlQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    // Return the results
    return results;
  } catch (error) {
    // Throw an error with a meaningful message
    throw new Error(error.message);
  }
};
exports.allDataMaxStockLevel = async () => { 
  try {
    // Retrieve active databases
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb } = getDatabases(activeDatabases); // Ensure correct reference
    const stockmasterDbName = stockmasterDb.getDatabaseName(); // Get the database name

    // Define the SQL query to find products with a maximum stock level not equal to 0 and stock on hand less than maximum stock
    const sqlQuery = `
      SELECT * 
      FROM ${stockmasterDbName}.tblproducts
      WHERE Maxstock <> 0 
        AND StockonHand < Maxstock
    `;

    // Execute the query using the stockmasterDb connection
    const results = await stockmasterDb.query(sqlQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
    });

    // Check if any results were returned
    if (results.length === 0) {
      throw new Error('No data found');
    }

    // Return the results
    return results;
  } catch (error) {
    // Throw an error with a meaningful message
    throw new Error(error.message);
  }
};
exports.sixWeek = async (requestBody) => {
  try {
    // Progress bar tracking variables
    let PB1Value = 0;
    const PB1Max = 6; // Weeks
    let PB2Value = 0;
    const PB2Max = 4; // Sub-steps per week
    let lblWeekNo = '';

    console.log('Initializing Process...');
    console.log(`Progress: ${PB1Value}/${PB1Max} - PB2: ${PB2Value}/${PB2Max}`);

    // Get active databases
    const activeDatabases = databaseController.getActiveDatabases();
    const { debtorsDb, stockmasterDb, hostDb, historyDb } = getDatabases(activeDatabases);

    if (!debtorsDb || !stockmasterDb || !hostDb || !historyDb) {
      throw new Error('Required databases not found');
    }

    // Clear temporary data from tmpavgsale table (if needed)
    await hostDb.query('DELETE FROM tmpavgsale', { type: QueryTypes.DELETE });

    // Extract request body values
    const { OptSupplier, OptCategory, txtSupplierCode, txtCategoryNo, txtSub1No, txtSub2No, startDate } = requestBody;

    // Log the start date
    console.log(`Start Date for Week Calculation: ${startDate}`);

    // Handle data insertion based on selected option (Supplier or Category)
    if (OptSupplier) {
      await insertData(stockmasterDb, hostDb, 'supplier', txtSupplierCode);
    } else if (OptCategory) {
      await insertData(stockmasterDb, hostDb, 'category', txtCategoryNo, txtSub1No, txtSub2No);
    }

    // Dynamically calculate the week data based on the provided startDate
    const weekData = generateWeekData(startDate);

    // Log the first and last week dates from weekData
    console.log(`Start Date of Week 1: ${weekData[0].startDate}`);
    console.log(`End Date of Week 6: ${weekData[5].endDate}`);

    // Loop through each week to process the data
    for (let i = 0; i < PB1Max; i++) {
      const { startDate, endDate } = weekData[i];
      PB1Value++;  // Increment main progress bar
      lblWeekNo = `Week ${i + 1}`;
      console.log(`Processing ${lblWeekNo} from ${startDate} to ${endDate}`);

      // Simulate the data processing for this week (without updating the table)
      await processWeekData(i + 1, startDate, endDate, stockmasterDb, hostDb);

      // Update PB2 progress (sub-step tracking)
      PB2Value = Math.round((PB1Value / PB1Max) * PB2Max);
      console.log(`Progress: ${PB1Value}/${PB1Max} - PB2: ${PB2Value}/${PB2Max}`);
    }

    // Check if records are inserted in tmpavgsale
    const recordsFound = await checkForRecords(hostDb);
    let insertedData = [];
    if (recordsFound) {
      // Fetch the inserted data from tmpavgsale
      insertedData = await hostDb.query('SELECT * FROM tmpavgsale', { type: QueryTypes.SELECT });
      console.log("Print Button Enabled...");
    }

    // Fetch the current transaction data
    const currentTranData = await fetchCurrentTranData(historyDb, startDate, weekData);

    // Merge the insertedData with currentTranData
    const mergedData = insertedData.map((data) => {
      const currentTran = currentTranData[data.StockCode];  // Assuming StockCode is the key for current transaction data

      // Merge the week-wise data (week1 to week6) from currentTranData into insertedData
      return {
        ...data,  // original data from insertedData
        // currentTran: currentTran || {},  // Add corresponding current transaction data
        // weekData: currentTran ? [
        //   currentTran.week1, currentTran.week2, currentTran.week3,
        //   currentTran.week4, currentTran.week5, currentTran.week6
        // ] : [0, 0, 0, 0, 0, 0]  // Default to 0 if no data
        weeks1: currentTran ? currentTran.week1 : 0,
        weeks2: currentTran ? currentTran.week2 : 0,
        weeks3: currentTran ? currentTran.week3 : 0,
        weeks4: currentTran ? currentTran.week4 : 0,
        weeks5: currentTran ? currentTran.week5 : 0,
        weeks6: currentTran ? currentTran.week6 : 0
      };
    });

    console.log("Data Completed Successfully...");
    return { message: 'Data Completed Successfully', mergedData };

  } catch (error) {
    console.error('Error during data processing:', error);
    throw new Error('Error during data processing');
  }
};


// Insert Data Function (based on supplier or category)
async function insertData(stockmasterDb, hostDb, type, code, sub1No = null, sub2No = null) {
  const stockmasterDbName = stockmasterDb.getDatabaseName();
  let query = '';

  if (type === 'supplier') {
    query = `
      INSERT INTO tmpavgsale
      SELECT 
        c.creditorcode, 
        c.creditorname, 
        p.stockcode, 
        p.description1, 
        0, 0, 0, 0, 0, 0,
        p.MinStock, 
        p.MaxStock, 
        p.StockOnOrder, 
        p.StockOnHand, 
        p.LastCostPrice, 
        p.AvarageCostPrice, 
        p.MajorNo, '', 
        p.Sub1No, '', 
        p.Sub2No, ''
      FROM ${stockmasterDbName}.tblproducts AS p
      INNER JOIN ${stockmasterDbName}.tblcreditoritems AS c
        ON p.stockcode = c.stockcode
      WHERE c.creditorcode = :code
    `;
  } else if (type === 'category') {
    query = `
      INSERT INTO tmpavgsale
      SELECT 
        '0', '0', p.stockcode, p.description1, 0, 0, 0, 0, 0, 0,
        p.MinStock, 
        p.MaxStock, 
        p.StockOnOrder, 
        p.StockOnHand, 
        p.LastCostPrice, 
        p.AvarageCostPrice, 
        p.MajorNo, '', 
        p.Sub1No, '', 
        p.Sub2No, ''
      FROM ${stockmasterDbName}.tblproducts AS p
      WHERE p.majorno = :code
        AND p.sub1no = :sub1No 
        AND p.sub2no = :sub2No
    `;
  }

  try {
    await hostDb.query(query, { replacements: { code, sub1No, sub2No }, type: QueryTypes.INSERT });
    console.log(`${type.charAt(0).toUpperCase() + type.slice(1)} data inserted successfully.`);
  } catch (error) {
    console.error(`Error inserting ${type} data:`, error);
    throw new Error(`Error inserting ${type} data`);
  }
}

// Process Data for a Specific Week (mimicking VB code without update)
async function processWeekData(week, startDate, endDate, stockmasterDb, hostDb) {
  const stockmasterDbName = stockmasterDb.getDatabaseName();

  try {
    // Format dates as in VB code style
    const formattedStartDate = format(new Date(startDate), 'yyyy-MM-dd') + " 00:00:01";
    const formattedEndDate = format(new Date(endDate), 'yyyy-MM-dd') + " 23:59:59";

    // Log the processed data (mimicking VB-style logging)
    console.log(`Week ${week} processing data: From ${formattedStartDate} to ${formattedEndDate}`);

    // Simulate logic without actually updating any database
    console.log(`Simulating processing of week ${week}...`);
    // Optionally add any calculation or processing steps here if needed.

    // Log completion of this weeks processing
    console.log(`Processed week ${week}: From ${formattedStartDate} to ${formattedEndDate}`);
  } catch (error) {
    console.error(`Error processing data for week ${week}:`, error);
    throw new Error(`Error processing data for week ${week}`);
  }
}

// Check for Records in tmpavgsale
async function checkForRecords(hostDb) {
  const query = 'SELECT COUNT(*) FROM tmpavgsale';
  const result = await hostDb.query(query, { type: QueryTypes.SELECT });
  return result[0]['COUNT(*)'] > 0;
}

// Generate week data dynamically based on the start date
function generateWeekData(startDate) {
  const weeks = [];
  const start = new Date(startDate);
  for (let i = 0; i < 6; i++) {
    const weekStartDate = dateFns.addWeeks(start, i);
    const weekEndDate = dateFns.addDays(weekStartDate, 6);
    weeks.push({
      startDate: format(weekStartDate, 'yyyy-MM-dd'),
      endDate: format(weekEndDate, 'yyyy-MM-dd')
    });
  }

  // Log the first and last week dates
  console.log(`Start Date of Week 1: ${weeks[0].startDate}`);
  console.log(`End Date of Week 6: ${weeks[5].endDate}`);

  return weeks;
}


async function fetchCurrentTranData(historyDb, startDate, weekData) {
  try {
    const firstStartDate = weekData[0]?.startDate;
    const lastEndDate = weekData[weekData.length - 1]?.endDate;

    console.log(`Fetching current transaction data from Start Date: ${firstStartDate}, End Date: ${lastEndDate}`);

    // Extract year from startDate
    const startYear = getYear(new Date(startDate));

    // Get all tables in the database
    const tables = await historyDb.query('SHOW TABLES', { type: QueryTypes.SELECT });

    // Filter tables to include only those matching the year in their name
    const matchingTables = tables.filter(table => {
      const tableName = table['Tables_in_' + historyDb.getDatabaseName()];
      const tableYearMonthMatch = tableName.match(/(\d{6})/);

      if (tableYearMonthMatch) {
        const tableYear = parseInt(tableYearMonthMatch[0].slice(0, 4), 10);
        const tableMonth = parseInt(tableYearMonthMatch[0].slice(4, 6), 10);

        // Check if the table's year matches and its month is within start and end range
        return (
          tableName.endsWith('tbldata_current_tran') &&
          tableYear === startYear &&
          tableMonth >= getMonth(new Date(startDate)) + 1 &&
          tableMonth <= getMonth(new Date(lastEndDate)) + 1
        );
      }

      return false;
    });

    if (matchingTables.length === 0) {
      console.log('No matching tables found for the specified year and month range.');
      return [];
    }

    // Initialize an object to hold the grouped data by week
    const allGroupedData = {};

    // Initialize a result object with weeks
    const weeklyData = {
      week1: 0,
      week2: 0,
      week3: 0,
      week4: 0,
      week5: 0,
      week6: 0
    };

    let stopFetching = false;  // Flag to stop fetching tables after reaching the end date

    // Loop through each matching table and fetch data
    for (const table of matchingTables) {
      const tableName = table['Tables_in_' + historyDb.getDatabaseName()];
      console.log(`Fetching data from table: ${tableName}`);

      // If endDate has been reached, stop searching tables
      if (stopFetching) {
        console.log('End date reached, stopping further table searches.');
        break;
      }

      // Query all data from the current table for the specific week range
      for (let i = 0; i < weekData.length; i++) {
        const { startDate, endDate } = weekData[i];

        const query = `
          SELECT * 
          FROM ${tableName}
          WHERE datetime >= :startDate AND datetime <= :endDate
        `;

        const data = await historyDb.query(query, {
          replacements: { 
            startDate: format(new Date(startDate), 'yyyy-MM-dd') + " 00:00:00", 
            endDate: format(new Date(endDate), 'yyyy-MM-dd') + " 23:59:59"
          },
          type: QueryTypes.SELECT
        });

        // If data is found, set stop flag
        if (data.length > 0) {
          stopFetching = true;
        }

        // Group the data by stockcode and calculate total quantity for each stockcode per week
        data.forEach(item => {
          const { stockcode, qty } = item;

          if (!allGroupedData[stockcode]) {
            allGroupedData[stockcode] = {
              week1: 0, week2: 0, week3: 0, week4: 0, week5: 0, week6: 0
            };
          }

          // Add the quantity to the respective week
          allGroupedData[stockcode][`week${i + 1}`] += qty;
        });
      }
    }

    return allGroupedData;
  } catch (error) {
    console.error('Error fetching transaction data:', error);
    throw error;
  }
}


exports.saleRepCommission = async (DateFrom, DateTo) => {
  try {
    const activeDatabases = databaseController.getActiveDatabases();
    const { stockmasterDb, hostDb } = getDatabases(activeDatabases);
    const stockmasterDbName = stockmasterDb.getDatabaseName();
    const hostDbName = hostDb.getDatabaseName();

    // Fetch the data to be inserted
    const selectQuery = `
      SELECT * FROM ${stockmasterDbName}.tbldata_salesrep
      WHERE ${stockmasterDbName}.tbldata_salesrep.datetime BETWEEN :dateFrom AND :dateTo
    `;
    
    const dataToInsert = await stockmasterDb.query(selectQuery, {
      type: stockmasterDb.QueryTypes.SELECT,
      replacements: {
        dateFrom: DateFrom,
        dateTo: DateTo
      }
    });

    if (dataToInsert.length === 0) {
      throw new Error('No data found');
    }

    // Insert the data into the host database
    const insertQuery = `
      INSERT INTO ${hostDbName}.tmpdata_salesrep
      SELECT * FROM ${stockmasterDbName}.tbldata_salesrep
      WHERE ${stockmasterDbName}.tbldata_salesrep.datetime BETWEEN :dateFrom AND :dateTo
    `;

    await hostDb.query(insertQuery, {
      type: hostDb.QueryTypes.INSERT,
      replacements: {
        dateFrom: DateFrom,
        dateTo: DateTo
      }
    });

    console.log('Data inserted successfully.');
    return dataToInsert; // Return the data that was inserted
  } catch (error) {
    console.error('Error inserting data:', error.message);
    throw new Error(error.message);
  }
};
